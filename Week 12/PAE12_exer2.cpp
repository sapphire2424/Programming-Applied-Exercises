/* 2025年度 プログラミング応用演習 第12回 演習プログラム(2) - PAE12_exer2
====================================================================================================
■グラフが一筆書き可能かどうかをチェックするプログラム
・全ての辺を1度だけ通る経路があるかどうか．
・#if 1でグラフA，#if 0でグラフBで実行する．
==================================================================================================*/
#include <iostream>
#include <vector>

//==================================================================================================
int main(void)
{
    // 隣接行列
#if 0
    // グラフA
    std::vector<std::vector<double>> E_mtx = {
        { 0, 1, 0, 0, 0, 0, 0},
        { 1, 0, 1, 0, 0, 1, 0},
        { 0, 1, 0, 1, 0, 0, 0},
        { 0, 0, 1, 0, 1, 1, 0},
        { 0, 0, 0, 1, 0, 1, 0},
        { 0, 1, 0, 1, 1, 0, 1},
        { 0, 0, 0, 0, 0, 1, 0}
    };
#else
    // グラフB
    std::vector<std::vector<double>> E_mtx = {
        { 0, 1, 0, 0, 0, 0, 1},
        { 1, 0, 1, 0, 0, 0, 0},
        { 0, 1, 0, 1, 0, 0, 0},
        { 0, 0, 1, 0, 1, 0, 0},
        { 0, 0, 0, 1, 0, 1, 0},
        { 0, 0, 0, 0, 1, 0, 1},
        { 1, 0, 0, 0, 0, 1, 0}
    };
#endif

    int     N = E_mtx.size();       // 行列のサイズ
    int     start_id = -1;          // 一筆書き開始頂点のインデックス
    bool    conn = true;            // 連結グラフか否か
    int     odd_cnt = 0;            // 頂点の次数(隣接数)のカウント

    std::vector<bool>   used(N, false);     // 使用済み頂点か否か
    std::vector<int>    deg(N, 0);          // 各頂点の次数
    std::vector<int>    stack;

    // 各頂点の次数を計算する．
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (E_mtx[i][j] != 0) {
                deg[i]++;
            }
        }
    }

    // 辺を持つ頂点(始点)を探す．
    for(int i=0; i<N; i++) {
        if(deg[i] > 0) {
            start_id = i;
            break;
        }
    }

    if(start_id == -1) {
        std::cout << "辺が1本もないグラフです．" << std::endl;
        return 0;
    }

    // 連結を調査する．
    stack.push_back(start_id);
    used[start_id] = true;

    while (!stack.empty()) {
        int u = stack.back();
        stack.pop_back();

        for (int v = 0; v < N; v++) {
            if (E_mtx[u][v] != 0 && !used[v]) {
                used[v] = true;
                stack.push_back(v);
            }
        }
    }

    // 辺を持つ頂点がすべて訪問済みか確認する．
    for(int i=0; i<N; i++) {
        if(deg[i] > 0 && !used[i]) {
            conn = false;
            break;
        }
    }

    if(conn == false) {
        std::cout << "グラフが連結ではありません． " << std::endl;
        return 0;
    }

    // 次数が奇数となっている頂点の数を数える．
    for (int i = 0; i < N; i++) {
        if (deg[i] % 2 != 0) {
            odd_cnt++;
        }
    }

    // 一筆書き可否を判定する．
    std::cout << "一筆書き";
    if(odd_cnt == 0 || odd_cnt == 2) {
        std::cout << "できます．" << std::endl;
    } else {
        std::cout << "できません． " << std::endl;
    }

    return 0;
}


/* 実行結果 ========================================================================================

[グラフAの場合]
一筆書きできません．

----------------------------------------------------------------------------------------------------
[グラフBの場合]
一筆書きできます．

==================================================================================================*/
